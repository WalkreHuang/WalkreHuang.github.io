<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[公司学习笔记]]></title>
    <url>%2F2017%2F11%2F06%2Fcompany-record%2F</url>
    <content type="text"><![CDATA[第一天一转眼，我已经进入了深圳一家公司，中间的过程也只能用幸运二字来总结。不得不感叹时光飞逝啊！好了，进入正题。以前都是使用别人写好的插件完成图片预览。今天发现h5的一个特性（FileReader）能够非常方便快速的实现图片阅览。代码如下： 123456789101112&lt;input id=&quot;file&quot; ;=&quot;&quot; onchange=&quot;c()&quot; type=&quot;file&quot;&gt;&lt;br&gt;&lt;img src=&quot;&quot; id=&quot;show&quot; width=&quot;200&quot;&gt;&lt;script&gt;function c () &#123; var r= new FileReader(); f=document.getElementById(&apos;file&apos;).files[0]; r.readAsDataURL(f); r.onload=function (e) &#123; document.getElementById(&apos;show&apos;).src=this.result; &#125;;&#125;&lt;/script&gt; 就是这么简单,嘻嘻。。。 dfsdfddd tp3.2中踩到的坑：注：此查询方式只适用于tp5.0，哈哈哈哈12345public function getFoodsByOrder($orderId) &#123; $orderFood = M(&apos;OrderItem&apos;)-&gt;join(&apos;left join __ORDER__ AS O ON O.orderID = res_order_item.orderID&apos;)-&gt;join(&apos;left join res_food ON res_food.foodID = res_order_item.foodID&apos;)-&gt;where(&quot;res_order_item.orderID&quot;,$orderId)-&gt;select(); return $orderFood; &#125; 一下午基本都在这里绕圈，这种情况下的where居然没有起作用，具体的可以通过查看log中的sql文件定位问题。发现where条件并没有起作用，简直一脸懵逼。看来以后还是跟老大说的一样，有些情况下直接写原生的sql语句要来的方便一点，而且出错率也会降低。将where中改成where(“res_order_item.orderID = $orderId”)就可以正常获取需要的数据了。 续：浅析auth与rbac后台权限控制的区别 auth是基于节点的权限控制,Rbac是基于角色的访问权限控制。直观的从表结构来看：Auth更加简洁一些Auth包含四张表分别是：auth_rule规则表；auth_group用户组表；auth_group_access用户组明细表；sys_user用户表。Rbac则包含5张表分别是：user用户表；role角色表；permission权限表；user_role用户角色表；role_permission角色权限表。 马上要接触巴巴赢客的项目了，今天算是初步的了解吧。 整理一下下午获取到的信息：对与一个接口来说：什么最重要？文档，没错，第一步就是要定义好开发的接口文档，文档里定义完相关参数以及返回值信息之后，编写相应的代码便会如虎添翼一般迅捷，高效！！ 对应返回值而言，都是以json格式传递，而使用json_encode()返回json字符串时，默认情况下：中文会乱码。解决办法如下：json_encode($resInfo, JSON_UNESCAPED_UNICODE);是的，只需要在第二个参数上加上上面的常量，输出的中文就不会乱码了。 PHP中判空函数的比较最近与前端对接时，发现正确的使用判空函数是尤其重要的一件事情，不然参数校验这块永远会有意想不到的情况出现。常用的判空函数有：empty,is_null,isset对于empty函数官方的解释是：用来判断一个变量是否被认为是空的。当一个变量并不存在，或者它的值等同于FALSE，那么它会被认为不存在。如果变量不存在的话，empty()并不会产生警告。使用empty时，以下的东西被认为是空的： “” (空字符串)0 (作为整数的0)0.0 (作为浮点数的0)“0” (作为字符串的0)NULLFALSEarray() (一个空数组)$var; (一个声明了，但是没有值的变量) 对于isset函数，官方的解释是： 检测变量是否已设置并且非 NULL，如果已经使用 unset() 释放了一个变量之后，它将不再是 isset()。若使用 isset() 测试一个被设置成 NULL 的变量，将返回 FALSE。同时要注意的是 null 字符（”\0”）并不等同于 PHP 的 NULL 常量。 斜体部分是重点，空字符串是会被当做已经设置的值。。。（不看手册真难发现这个坑啊！！） 对于is_null函数，官方解释是：检测变量是否为 NULL，如果 var 是 null 则返回 TRUE，否则返回 FALSE。没错就是这么简单粗暴，只是单纯判断变量的值是不是NULL，是返回true，不是则返回false。 利用PHPExcel类库将Excel表中的数据导入到数据库中（tp5中完成）一.前期准备工作 首先去PHPExcel官网下载PHPExcel类库，地址：https://github.com/PHPOffice/PHPExcel ，我们只要Classes文件夹就行了，其他的是些例子，有时间可以研究一下。其次需要准备一张Excel表格，内容不要求多，简单实用就好。 二.具体操作流程及实现思路首先将我们下好的Classes文件夹改名为PHPExcel（这个根据个人喜好命名），放到tp5的vendor文件夹下面。 思路解析：首先我们将Excel表格上传到服务器—&gt;然后将表格里面的数据读取出来保存在数组里—&gt;再讲将数组里面的数据添加至数据库。 三.案例展示前台代码展示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;tp5-表格导入&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; background: #f8f8f8; &#125; .header&#123; background: #fff; padding:15px; font-size: 20px; font-weight: 600; border-bottom: 1px solid #e6e6e6; margin-bottom: 50px; &#125; footer&#123; background: #fff; padding:30px 0; text-align: center; position: fixed; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-12 header&quot;&gt; excel数据导入 &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-12&quot; style=&quot;height:50px;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-md-4 hui-margin-top-30 hui-padding-all-20 hui-background-color-white&quot;&gt; &lt;form action=&quot;/excelAdd&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputFile&quot;&gt;导入Excel表格&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;exampleInputFile&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;height: 100px;&quot;&gt;&lt;/div&gt; &lt;footer style=&quot;bottom: 0;width: 100%;&quot;&gt; &amp;copy;2017 Huang &lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; 后台代码展示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//展示上传文件public function excel() &#123; return view(); &#125;//表单post提交的地址 public function excelAdd() &#123; if(request()-&gt;isPost())&#123; $file = request()-&gt;file(&apos;file&apos;); $info = $file-&gt;move(ROOT_PATH . &apos;public&apos;.DS.&apos;uploads&apos;.DS.&apos;excel&apos;); if($info) &#123; //获取文件所在目录 $path = ROOT_PATH.&apos;public&apos;.DS.&apos;uploads&apos;.DS.&apos;excel/&apos;.$info-&gt;getSaveName(); vendor(&quot;PHPExcel.PHPExcel&quot;); $extension = $info-&gt;getExtension(); //判断文件是否为xlsx格式 if( $extension ==&apos;xlsx&apos; ) &#123; $objReader = new \PHPExcel_Reader_Excel2007(); &#125; else &#123; $objReader = new \PHPExcel_Reader_Excel5(); &#125; //获取excel文件 $objPHPExcel = $objReader-&gt;load($path,$encode=&apos;utf-8&apos;); $sheet = $objPHPExcel-&gt;getSheet(0);//激活当前表 $highestRow = $sheet-&gt;getHighestRow();//取得总行数 $highestColumn = $sheet-&gt;getHighestColumn();//取得总列数 $a = 0; //将表格中的数据循环到数据中 for($i=2;$i&lt;=$highestRow;$i++) &#123; $data[$a][&apos;studentNum&apos;] = $objPHPExcel-&gt;getActiveSheet()-&gt;getCell(&quot;A&quot;.$i)-&gt;getValue(); $data[$a][&apos;studentName&apos;] = $objPHPExcel-&gt;getActiveSheet()-&gt;getCell(&quot;B&quot;.$i)-&gt;getValue(); $data[$a][&apos;telphone&apos;] = $objPHPExcel-&gt;getActiveSheet()-&gt;getCell(&quot;C&quot;.$i)-&gt;getValue(); $data[$a][&apos;studyMethod&apos;] = $objPHPExcel-&gt;getActiveSheet()-&gt;getCell(&quot;D&quot;.$i)-&gt;getValue(); $data[$a][&apos;solve&apos;] = $objPHPExcel-&gt;getActiveSheet()-&gt;getCell(&quot;E&quot;.$i)-&gt;getValue(); $a++; &#125; //向数据库中插入数据 $res = db(&apos;phpexcel&apos;)-&gt;insertAll($data); if($res) &#123; $this-&gt;success(&apos;导入Excel数据成功！&apos;); &#125;else&#123; $this-&gt;error(&apos;导入Excel数据失败！&apos;); &#125; &#125; else &#123; // 上传失败获取错误信息 $this-&gt;error($file-&gt;getError()); &#125; &#125; &#125; 其实上面的方法都是别人以及实现的功能（参考地址），但是我从收获最大的是对于表格中多组数据的插入，以前都是在foreach循环中执行mysql语句，但今天发现了一种新大陆的赶脚啊，可以先使用for循环组装成一个多维数组再使用insertAll()方法直接一次插入。对mysql数据库而言也是一个性能的提升! 在使用pdo过程中使用预处理方式运行limit语句时踩到的坑在编写代码时发现了PDO对象处理带有LIMIT子句的SQL语句时，不能正确处理LIMIT子句中的占位符。eg: 123456789101112131415161718192021222324252627282930/** * 读取文章列表 * @param [type] $userId [文章作者id] * @param integer $page [页码] * @param integer $size [每页显示条数] * @return [type] [description] */ public function getList($userId,$page=1,$size=10) &#123; if($size &gt; 50) &#123; throw new Exception(&apos;分页数目不能超过50&apos;,ErrorCode::PGAE_SIZE_ILLEGAL); &#125; $sql = &quot;SELECT * FROM article WHERE user_id = ? LIMIT ?,?&quot;; //第一页特殊处理 if($page == 1) &#123; $limit = 0; &#125; else &#123; $limit = ($page-1) * $size; &#125; $stmt = $this-&gt;_db-&gt;prepare($sql); $data = [$userId,$limit,$size]; $stmt-&gt;execute($data);//bug $postInfos = $stmt-&gt;fetchAll(PDO::FETCH_ASSOC); if(empty($postInfos)) &#123; throw new Exception(&apos;该用户没有创建任何文章&apos;,ErrorCode::POST_NOT_FOUND); &#125; return $postInfos; &#125; 使用上述方式执行分页查询时，会无法查询出结果，$postInfos始终都是空值。在google之后发现并不是我一个人遇到了这种情况，这是属于pdo中尚未修复的Bug,解决的办法如下：： 12345//官方bug 解决的方法是，使用bindValue方法绑定值到SQL语句，并且指定第三个参数为INT类型 $stmt-&gt;bindValue(1, $userId, PDO::PARAM_INT); $stmt-&gt;bindValue(2, $limit, PDO::PARAM_INT); $stmt-&gt;bindValue(3, $size, PDO::PARAM_INT); $stmt-&gt;execute(); 将第一份$data数组地方的代码改成上述代码就可以正常查询了。 phpstorm 中的超实用的快捷键之前一直不使用phpstorm 编码，除了运行吃资源外，最直接的一个因素其实是：没有找到像sublime text 中ctrl+D多行游标编辑快捷键，今天终于找到了在phpstorm中相应的快捷键了:Alt+j;移除无用的use对应的快捷键是 Ctrl+Alt+O;Ctrl+Alt+L格式化代码;向左/右缩进的快捷键是 shift+tab/tab .好了，估计以后在公司很大一部分都会使用phpstorm 编码了。说干就干，开撸！！！ 承接上文，实在惭愧，今天才正式的搭建好了 phpstorm 开发的一些环境。现在我的 phpstorm 可以作为 svn 客户端，ftp 客户端，以后只需要专注于代码，其他的工作就是几个快捷键可以搞定的事情了。附上phpstorm如何连接ftp服务器及phpstorm配置Svn客户端的软文。 phpstrom 中如何配置忽略目录到svn最近在使用 tp5 框架开发时，发现 runtime 目录一直在提交列表里，但是根本又不需要提交这个目录（用过 tp5 的都知道，这是个放系统缓存和日志的地方）。一开始是如下图操作的：但是提交时发现还是会提交到版本库中，后来网上 google 到可以通过 changeList 这个东西做做文章，将一些不想提交的目录或文件先存放到另一个空间中。这个有点类似 ignore 的功能，可以排除或忽略某些不想被提交的文件，但是它是 IDE 自带的，是本地实现的不会影响 Subversion、Git 等本身的设置。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git使用中的报错情况]]></title>
    <url>%2F2017%2F03%2F11%2Ftest-site%2F</url>
    <content type="text"></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>实战经验</tag>
      </tags>
  </entry>
</search>
